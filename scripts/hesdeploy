#!/usr/local/bin/python

import boto3
from botocore.exceptions import ClientError

import argparse
import base64
import os
import zipfile
import time
import sys

import deployConfig
from datetime import datetime
from hesburgh import heslog, hesutil

timestamp = datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
deployDir = "tmp_%s" % timestamp


########### ZIP
def zipDir(zipf, toZip):
  if os.path.isfile(toZip):
    filePath = toZip
    archivePath = os.path.relpath(toZip, '..')
    heslog.verbose(toZip)
    zipf.write(toZip, archivePath)
  elif os.path.isdir(toZip):
    for root, dirs, files in os.walk(toZip):
      for file in files:
        filePath = os.path.join(root, file)
        archivePath = os.path.relpath(os.path.join(root, file), os.path.join(toZip, '..'))
        zipf.write(filePath, archivePath)
        heslog.verbose(filePath)
  else:
    heslog.error("trying to zip %s that is neither file or dir" % toZip)


def makeZip(zipName, paths):
  zipf = zipfile.ZipFile(zipName, 'w', zipfile.ZIP_DEFLATED)
  heslog.verbose("Make zip %s" % zipName)
  for path in paths:
    zipDir(zipf, path)
  zipf.close()


############ LIFECYCLE
class Abort(Exception):
  pass

class Lifecycle(object):
  def __init__(self, args, config, timer):
    self.args = args
    self.config = config
    self.timer = timer
    self.deployFailure = False


  def _check(self, name, *exitOn):
    for e in exitOn:
      if vars(self.args).get(e):
        heslog.info("Skipping %s because '%s' was specified" % (name, e))
        return False
    return True


  def _encrypt(self, kmsKey, key, val):
    if kmsKey:
      heslog.info("Encrypting %s" % key)

      client = boto3.client('kms')
      response = client.encrypt(
        KeyId=kmsKey,
        Plaintext=val,
      )
      return base64.b64encode(response.get("CiphertextBlob")).decode("utf-8")


  def _updateLambda(self, func, env, kmsKey):
    heslog.info("Updating lambda '%s'" % func)

    env = { k: self._encrypt(kmsKey, k, v) for k,v in env.iteritems() }

    client = boto3.client('lambda')
    response = client.update_function_configuration(
      FunctionName=func,
      Environment={
        'Variables': env
      },
    )


  def preDeploy(self):
    heslog.addContext(stage="preDeploy")

    if self._check("artifact creation", "noPublish"):
      if self.config.zips():
        os.mkdir(deployDir)

    if self._check("template validation", "noAws"):
      try:
        heslog.info("Validating Templates")
        client = boto3.client("cloudformation")
        for file in self.config.cloudformations():
          with open(file) as f:
            response = client.validate_template(TemplateBody=f.read())
            if file == self.config.cfcall():
              self.capabilities = response.get("Capabilities", [])
      except Exception as e:
        heslog.error(e)
        raise Abort("Validation Failure")


  def package(self):
    heslog.addContext(stage="package")
    heslog.info("Creating artifacts")

    if self.config.zips():
      for k,v in self.config.zips().iteritems():
        makeZip("%s/%s.zip" % (deployDir, k), v)
      heslog.info("Finished zipping in %ss" % (self.timer.step(True)))


  def publish(self):
    heslog.addContext(stage="publish")
    client = boto3.client('s3')

    try:
      if self._check("deploying files", "noAws"):
        heslog.info("Publishing to s3://%s/%s" % (self.args.deployBucket, self.config.deployFolder()))
        heslog.info("Uploading CF files")
        for file in self.config.cloudformations():
          heslog.verbose("Upload %s => s3://%s/%s/%s" % (file, self.args.deployBucket, self.config.deployFolder(), file))
          client.upload_file(file, self.args.deployBucket, '%s/%s' % (self.config.deployFolder(), file))
        if os.path.exists(deployDir):
          heslog.info("Uploading project artifacts")
          for root, dirs, files in os.walk(deployDir):
            for file in files:
              filename = "%s/%s" % (root, file)
              heslog.verbose("Upload %s => s3://%s/%s/%s" % (filename, self.args.deployBucket, self.config.deployFolder(), file))
              client.upload_file(filename, self.args.deployBucket, '%s/%s' % (self.config.deployFolder(), file))
        heslog.info("Finished publishing in %ss" % (self.timer.step(True)))
    except Exception as e:
      heslog.error(e)
      raise Abort("Publish Error")


  def createOrUpdate(self):
    client = boto3.client('cloudformation')
    stackName = self.config.stackName()
    path = self.config.deployFolder()
    rootTemplate = "https://s3.amazonaws.com/%s/%s/%s" % (self.args.deployBucket, path, self.config.cfcall())

    params = [ { "ParameterKey": k, "ParameterValue": v } for k,v in self.config.parameters().iteritems() ]
    tags = [ { "Key": k, "Value": v } for k,v in self.config.tags().iteritems() ]

    stackArgs = {
      "StackName": stackName,
      "TemplateURL": rootTemplate,
      "Parameters": params,
      "Capabilities": self.capabilities,
      "Tags": tags,
    }
    created = False

    if self._check("running cloudformation", "noAws", "publishOnly"):
      try:
        client = boto3.client('cloudformation')
        response = client.describe_stacks(
          StackName=stackName
        )
        created = True
      except ClientError:
        heslog.verbose("Stack %s does not exist" % (stackName))

      try:
        if created:
          heslog.addContext(stage="updateStack")
          heslog.info("Updating Stack '%s'" % stackName)
          response = client.update_stack(**stackArgs)
          waiterId = 'stack_update_complete'
          self.waitUpdate(response.get("StackId"))
        else:
          heslog.addContext(stage="createStack")
          heslog.info("Creating Stack '%s'" % stackName)
          response = client.create_stack(**stackArgs)
          waiterId = 'stack_create_complete'
          self.waitCreate(response.get("StackId"))
      except ClientError as e:
        heslog.error(e)
        self.deployFailure = True

      heslog.info("CF Finished in %ss" % (self.timer.step(True)))


  def postDeploy(self):
    heslog.addContext(stage="postDeploy")

    if (self._check("lambda update" , "noAws", "publishOnly")
        and len(self.config.lambdaVars()) > 0
        and not self.deployFailure):
      for lambdaConf in self.config.lambdaVars():
        self._updateLambda(lambdaConf.get("name"), lambdaConf.get("vars", {}), lambdaConf.get("key"))
      heslog.info("Finished Updating Lambdas in %ss" % (self.timer.step(True)))

    # remove temp directory
    if self._check("delete local artifacts", "keepLocal") and os.path.exists(deployDir):
      for root, dirs, files in os.walk(deployDir):
        for file in files:
          heslog.verbose("Removing tmp file %s/%s" % (root, file))
          os.remove(os.path.join(root, file))
      heslog.verbose("Removing tmp dir %s" % deployDir)
      os.rmdir(deployDir)


  def deleteStack(self):
    heslog.addContext(stage="deleteStack")
    client = boto3.client('cloudformation')
    stackName = self.config.stackName()
    stackId = None

    try:
      client = boto3.client('cloudformation')
      response = client.describe_stacks(
        StackName=stackName
      )
      stackId = response.get("Stacks", [])[0].get("StackId")
    except Exception as e:
      raise Abort(e)


    if self._check("stack delete", "noAws"):
      heslog.info("Deleting stack %s" % stackName)
      response = client.delete_stack(
        StackName=stackName,
      )

      self.waitDelete(stackId)
      heslog.info("Deleted stack in %s" % (self.timer.step(True)))


  def run(self):
    try:
      if not self.args.noAws and not hesutil.getEnv("AWS_ROLE_ARN"):
        heslog.error("When 'noAws' has not been specified you must assume a role to run this script")
        return

      if self.args.noPublish and not self.args.deployFolder:
        heslog.error("When specifying 'noPublish' you must also specify 'deployFolder'")
        return

      if self.args.delete:
        self.deleteStack()
        return

      if self._check("publish and deploy", "envOnly"):
        self.preDeploy()

        if self._check("publish steps", "noPublish"):
          self.package()
          self.publish()

        if self._check("cloudformation", "publishOnly", "envOnly"):
          self.createOrUpdate()

      self.postDeploy()
    except (Abort, ClientError) as e:
      heslog.setContext({})
      heslog.info("Aborting due to %s" % e)
    heslog.setContext({})

  ############ CF WAIT
  def CFWait(self, stackId, doneState, progressState):
    client = boto3.client('cloudformation')
    try:
      while True:
        sys.stdout.write(".")
        sys.stdout.flush()
        response = client.describe_stacks(
          StackName=stackId
        )

        stack = response.get("Stacks", [])[0]
        status = stack.get("StackStatus")
        if status == doneState:
          print
          return True
        elif status != progressState:
          self.deployFailure = True
          print
          if status == "ROLLBACK_IN_PROGRESS":
            heslog.error(stack.get("StackStatusReason"))
          else:
            print status
            print stack.get("StackStatusReason")
          return False

        time.sleep(7)
    except Exception as e:
      heslog.error(e)


  def waitCreate(self, stackId):
    if self.CFWait(stackId, "CREATE_COMPLETE", "CREATE_IN_PROGRESS"):
      heslog.info("Stack Creation Complete")


  def waitUpdate(self, stackId):
    if self.CFWait(stackId, "UPDATE_COMPLETE", "UPDATE_IN_PROGRESS"):
      heslog.info("Stack Update Complete")


  def waitDelete(self, stackId):
    if self.CFWait(stackId, "DELETE_COMPLETE", "DELETE_IN_PROGRESS"):
      heslog.info("Stack Delete Complete")


if __name__ == "__main__":
  heslog.addContext(stage="init")

  parser = argparse.ArgumentParser()
  parser.add_argument('--stage', '-s', type=str, required=True,
    help='The stage to deploy to')
  parser.add_argument('--config', '-c', type=str,
    help='Config file to use as input')

  # override defaults
  parser.add_argument('--deployBucket', type=str, default="testlibnd-cf",
    help='The bucket the artifacts will be put into')
  parser.add_argument('--stackName', type=str,
    help='Override the stack name (default is $SERVICE-$STAGE)')
  parser.add_argument('--deployFolder', type=str,
    help='Override the deployment folder NO BEGINNING SLASH (default is $SERVICE/$STAGE/$TIMESTAMP')

  # specify functionality
  parser.add_argument('--delete', action='store_true', dest='delete',
    help="Delete this stack")

  parser.add_argument('--publishOnly', action='store_true', dest='publishOnly',
    help="Publish files to the S3 bucket without calling the CF files")
  parser.add_argument('--envOnly', action='store_true', dest='envOnly',
    help="Update lambda environment without publishing/deploying")

  parser.add_argument('--noPublish', action='store_true', dest='noPublish',
    help="Don't create or publish artifacts (CF, code zip, etc) NOTE: You must override deployFolder if you specify this argument")
  parser.add_argument('--noAws', action='store_true', dest='noAws',
    help="Don't interact with aws at all")
  parser.add_argument('--keepLocal', action='store_true', dest='keepLocal',
    help="Don't delete locally created artifacts on completion")

  # Logging
  parser.add_argument('--verbose', action='store_true', dest='verbose',
    help="Verbose output")

  args = parser.parse_args()

  if args.verbose:
    heslog.setLevels()
  else:
    heslog.setLevels(heslog.LEVEL_INFO, heslog.LEVEL_WARN, heslog.LEVEL_ERROR)

  timer = hesutil.Timer(True)

  confName = args.config or "config.yml"
  config = deployConfig.Config(confName, args, timestamp)
  life = Lifecycle(args, config, timer)
  life.run()

  heslog.info("Total Time: %s" % timer.end())

